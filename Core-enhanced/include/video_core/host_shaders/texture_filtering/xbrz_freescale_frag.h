// Copyright 2022 Citra Emulator Project
// Licensed under GPLv2 or any later version
// Refer to the license.txt file included.

#pragma once

#include <string_view>

namespace HostShaders {

constexpr std::string_view XBRZ_FREESCALE_FRAG = {
"// Copyright 2023 Citra Emulator Project\n"
"// Licensed under GPLv2 or any later version\n"
"// Refer to the license.txt file included.\n"
"\n"
"//? #version 430 core\n"
"precision mediump float;\n"
"\n"
"layout(location = 0) in vec2 tex_coord;\n"
"layout(location = 0) out vec4 frag_color;\n"
"\n"
"layout(binding = 0) uniform sampler2D tex;\n"
"\n"
"#ifdef VULKAN\n"
"layout(push_constant, std140) uniform XbrzInfo {\n"
"    float scale;\n"
"};\n"
"#else\n"
"layout(location = 2) uniform float scale;\n"
"#endif\n"
"\n"
"const int BLEND_NONE = 0;\n"
"const int BLEND_NORMAL = 1;\n"
"const int BLEND_DOMINANT = 2;\n"
"const float LUMINANCE_WEIGHT = 1.0;\n"
"const float EQUAL_COLOR_TOLERANCE = 30.0 / 255.0;\n"
"const float STEEP_DIRECTION_THRESHOLD = 2.2;\n"
"const float DOMINANT_DIRECTION_THRESHOLD = 3.6;\n"
"\n"
"float ColorDist(vec4 a, vec4 b) {\n"
"    // https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.2020_conversion\n"
"    const vec3 K = vec3(0.2627, 0.6780, 0.0593);\n"
"    const mat3 MATRIX = mat3(K, -.5 * K.r / (1.0 - K.b), -.5 * K.g / (1.0 - K.b), .5, .5,\n"
"                             -.5 * K.g / (1.0 - K.r), -.5 * K.b / (1.0 - K.r));\n"
"    vec4 diff = a - b;\n"
"    vec3 YCbCr = diff.rgb * MATRIX;\n"
"    // LUMINANCE_WEIGHT is currently 1, otherwise y would be multiplied by it\n"
"    float d = length(YCbCr);\n"
"    return sqrt(a.a * b.a * d * d + diff.a * diff.a);\n"
"}\n"
"\n"
"bool IsPixEqual(const vec4 pixA, const vec4 pixB) {\n"
"    return ColorDist(pixA, pixB) < EQUAL_COLOR_TOLERANCE;\n"
"}\n"
"\n"
"float GetLeftRatio(vec2 center, vec2 origin, vec2 direction) {\n"
"    vec2 P0 = center - origin;\n"
"    vec2 proj = direction * (dot(P0, direction) / dot(direction, direction));\n"
"    vec2 distv = P0 - proj;\n"
"    vec2 orth = vec2(-direction.y, direction.x);\n"
"    float side = sign(dot(P0, orth));\n"
"    float v = side * length(distv * scale);\n"
"    return smoothstep(-sqrt(2.0) / 2.0, sqrt(2.0) / 2.0, v);\n"
"}\n"
"\n"
"#define P(x, y) textureOffset(tex, coord, ivec2(x, y))\n"
"\n"
"void main() {\n"
"    vec2 source_size = vec2(textureSize(tex, 0));\n"
"    vec2 pos = fract(tex_coord * source_size) - vec2(0.5, 0.5);\n"
"    vec2 coord = tex_coord - pos / source_size;\n"
"\n"
"    //---------------------------------------\n"
"    // Input Pixel Mapping:  -|x|x|x|-\n"
"    //                       x|A|B|C|x\n"
"    //                       x|D|E|F|x\n"
"    //                       x|G|H|I|x\n"
"    //                       -|x|x|x|-\n"
"    vec4 A = P(-1, -1);\n"
"    vec4 B = P(0, -1);\n"
"    vec4 C = P(1, -1);\n"
"    vec4 D = P(-1, 0);\n"
"    vec4 E = P(0, 0);\n"
"    vec4 F = P(1, 0);\n"
"    vec4 G = P(-1, 1);\n"
"    vec4 H = P(0, 1);\n"
"    vec4 I = P(1, 1);\n"
"    // blendResult Mapping: x|y|\n"
"    //                      w|z|\n"
"    ivec4 blendResult = ivec4(BLEND_NONE, BLEND_NONE, BLEND_NONE, BLEND_NONE);\n"
"    // Preprocess corners\n"
"    // Pixel Tap Mapping: -|-|-|-|-\n"
"    //                    -|-|B|C|-\n"
"    //                    -|D|E|F|x\n"
"    //                    -|G|H|I|x\n"
"    //                    -|-|x|x|-\n"
"    if (!((E == F && H == I) || (E == H && F == I))) {\n"
"        float dist_H_F = ColorDist(G, E) + ColorDist(E, C) + ColorDist(P(0, 2), I) +\n"
"                         ColorDist(I, P(2, 0)) + (4.0 * ColorDist(H, F));\n"
"        float dist_E_I = ColorDist(D, H) + ColorDist(H, P(1, 2)) + ColorDist(B, F) +\n"
"                         ColorDist(F, P(2, 1)) + (4.0 * ColorDist(E, I));\n"
"        bool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_H_F) < dist_E_I;\n"
"        blendResult.z = ((dist_H_F < dist_E_I) && E != F && E != H)\n"
"                            ? ((dominantGradient) ? BLEND_DOMINANT : BLEND_NORMAL)\n"
"                            : BLEND_NONE;\n"
"    }\n"
"    // Pixel Tap Mapping: -|-|-|-|-\n"
"    //                    -|A|B|-|-\n"
"    //                    x|D|E|F|-\n"
"    //                    x|G|H|I|-\n"
"    //                    -|x|x|-|-\n"
"    if (!((D == E && G == H) || (D == G && E == H))) {\n"
"        float dist_G_E = ColorDist(P(-2, 1), D) + ColorDist(D, B) + ColorDist(P(-1, 2), H) +\n"
"                         ColorDist(H, F) + (4.0 * ColorDist(G, E));\n"
"        float dist_D_H = ColorDist(P(-2, 0), G) + ColorDist(G, P(0, 2)) + ColorDist(A, E) +\n"
"                         ColorDist(E, I) + (4.0 * ColorDist(D, H));\n"
"        bool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_D_H) < dist_G_E;\n"
"        blendResult.w = ((dist_G_E > dist_D_H) && E != D && E != H)\n"
"                            ? ((dominantGradient) ? BLEND_DOMINANT : BLEND_NORMAL)\n"
"                            : BLEND_NONE;\n"
"    }\n"
"    // Pixel Tap Mapping: -|-|x|x|-\n"
"    //                    -|A|B|C|x\n"
"    //                    -|D|E|F|x\n"
"    //                    -|-|H|I|-\n"
"    //                    -|-|-|-|-\n"
"    if (!((B == C && E == F) || (B == E && C == F))) {\n"
"        float dist_E_C = ColorDist(D, B) + ColorDist(B, P(1, -2)) + ColorDist(H, F) +\n"
"                         ColorDist(F, P(2, -1)) + (4.0 * ColorDist(E, C));\n"
"        float dist_B_F = ColorDist(A, E) + ColorDist(E, I) + ColorDist(P(0, -2), C) +\n"
"                         ColorDist(C, P(2, 0)) + (4.0 * ColorDist(B, F));\n"
"        bool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_B_F) < dist_E_C;\n"
"        blendResult.y = ((dist_E_C > dist_B_F) && E != B && E != F)\n"
"                            ? ((dominantGradient) ? BLEND_DOMINANT : BLEND_NORMAL)\n"
"                            : BLEND_NONE;\n"
"    }\n"
"    // Pixel Tap Mapping: -|x|x|-|-\n"
"    //                    x|A|B|C|-\n"
"    //                    x|D|E|F|-\n"
"    //                    -|G|H|-|-\n"
"    //                    -|-|-|-|-\n"
"    if (!((A == B && D == E) || (A == D && B == E))) {\n"
"        float dist_D_B = ColorDist(P(-2, 0), A) + ColorDist(A, P(0, -2)) + ColorDist(G, E) +\n"
"                         ColorDist(E, C) + (4.0 * ColorDist(D, B));\n"
"        float dist_A_E = ColorDist(P(-2, -1), D) + ColorDist(D, H) + ColorDist(P(-1, -2), B) +\n"
"                         ColorDist(B, F) + (4.0 * ColorDist(A, E));\n"
"        bool dominantGradient = (DOMINANT_DIRECTION_THRESHOLD * dist_D_B) < dist_A_E;\n"
"        blendResult.x = ((dist_D_B < dist_A_E) && E != D && E != B)\n"
"                            ? ((dominantGradient) ? BLEND_DOMINANT : BLEND_NORMAL)\n"
"                            : BLEND_NONE;\n"
"    }\n"
"    vec4 res = E;\n"
"    // Pixel Tap Mapping: -|-|-|-|-\n"
"    //                    -|-|B|C|-\n"
"    //                    -|D|E|F|x\n"
"    //                    -|G|H|I|x\n"
"    //                    -|-|x|x|-\n"
"    if (blendResult.z != BLEND_NONE) {\n"
"        float dist_F_G = ColorDist(F, G);\n"
"        float dist_H_C = ColorDist(H, C);\n"
"        bool doLineBlend = (blendResult.z == BLEND_DOMINANT ||\n"
"                            !((blendResult.y != BLEND_NONE && !IsPixEqual(E, G)) ||\n"
"                              (blendResult.w != BLEND_NONE && !IsPixEqual(E, C)) ||\n"
"                              (IsPixEqual(G, H) && IsPixEqual(H, I) && IsPixEqual(I, F) &&\n"
"                               IsPixEqual(F, C) && !IsPixEqual(E, I))));\n"
"        vec2 origin = vec2(0.0, 1.0 / sqrt(2.0));\n"
"        vec2 direction = vec2(1.0, -1.0);\n"
"        if (doLineBlend) {\n"
"            bool haveShallowLine =\n"
"                (STEEP_DIRECTION_THRESHOLD * dist_F_G <= dist_H_C) && E != G && D != G;\n"
"            bool haveSteepLine =\n"
"                (STEEP_DIRECTION_THRESHOLD * dist_H_C <= dist_F_G) && E != C && B != C;\n"
"            origin = haveShallowLine ? vec2(0.0, 0.25) : vec2(0.0, 0.5);\n"
"            direction.x += haveShallowLine ? 1.0 : 0.0;\n"
"            direction.y -= haveSteepLine ? 1.0 : 0.0;\n"
"        }\n"
"        vec4 blendPix = mix(H, F, step(ColorDist(E, F), ColorDist(E, H)));\n"
"        res = mix(res, blendPix, GetLeftRatio(pos, origin, direction));\n"
"    }\n"
"    // Pixel Tap Mapping: -|-|-|-|-\n"
"    //                    -|A|B|-|-\n"
"    //                    x|D|E|F|-\n"
"    //                    x|G|H|I|-\n"
"    //                    -|x|x|-|-\n"
"    if (blendResult.w != BLEND_NONE) {\n"
"        float dist_H_A = ColorDist(H, A);\n"
"        float dist_D_I = ColorDist(D, I);\n"
"        bool doLineBlend = (blendResult.w == BLEND_DOMINANT ||\n"
"                            !((blendResult.z != BLEND_NONE && !IsPixEqual(E, A)) ||\n"
"                              (blendResult.x != BLEND_NONE && !IsPixEqual(E, I)) ||\n"
"                              (IsPixEqual(A, D) && IsPixEqual(D, G) && IsPixEqual(G, H) &&\n"
"                               IsPixEqual(H, I) && !IsPixEqual(E, G))));\n"
"        vec2 origin = vec2(-1.0 / sqrt(2.0), 0.0);\n"
"        vec2 direction = vec2(1.0, 1.0);\n"
"        if (doLineBlend) {\n"
"            bool haveShallowLine =\n"
"                (STEEP_DIRECTION_THRESHOLD * dist_H_A <= dist_D_I) && E != A && B != A;\n"
"            bool haveSteepLine =\n"
"                (STEEP_DIRECTION_THRESHOLD * dist_D_I <= dist_H_A) && E != I && F != I;\n"
"            origin = haveShallowLine ? vec2(-0.25, 0.0) : vec2(-0.5, 0.0);\n"
"            direction.y += haveShallowLine ? 1.0 : 0.0;\n"
"            direction.x += haveSteepLine ? 1.0 : 0.0;\n"
"        }\n"
"        origin = origin;\n"
"        direction = direction;\n"
"        vec4 blendPix = mix(H, D, step(ColorDist(E, D), ColorDist(E, H)));\n"
"        res = mix(res, blendPix, GetLeftRatio(pos, origin, direction));\n"
"    }\n"
"    // Pixel Tap Mapping: -|-|x|x|-\n"
"    //                    -|A|B|C|x\n"
"    //                    -|D|E|F|x\n"
"    //                    -|-|H|I|-\n"
"    //                    -|-|-|-|-\n"
"    if (blendResult.y != BLEND_NONE) {\n"
"        float dist_B_I = ColorDist(B, I);\n"
"        float dist_F_A = ColorDist(F, A);\n"
"        bool doLineBlend = (blendResult.y == BLEND_DOMINANT ||\n"
"                            !((blendResult.x != BLEND_NONE && !IsPixEqual(E, I)) ||\n"
"                              (blendResult.z != BLEND_NONE && !IsPixEqual(E, A)) ||\n"
"                              (IsPixEqual(I, F) && IsPixEqual(F, C) && IsPixEqual(C, B) &&\n"
"                               IsPixEqual(B, A) && !IsPixEqual(E, C))));\n"
"        vec2 origin = vec2(1.0 / sqrt(2.0), 0.0);\n"
"        vec2 direction = vec2(-1.0, -1.0);\n"
"        if (doLineBlend) {\n"
"            bool haveShallowLine =\n"
"                (STEEP_DIRECTION_THRESHOLD * dist_B_I <= dist_F_A) && E != I && H != I;\n"
"            bool haveSteepLine =\n"
"                (STEEP_DIRECTION_THRESHOLD * dist_F_A <= dist_B_I) && E != A && D != A;\n"
"            origin = haveShallowLine ? vec2(0.25, 0.0) : vec2(0.5, 0.0);\n"
"            direction.y -= haveShallowLine ? 1.0 : 0.0;\n"
"            direction.x -= haveSteepLine ? 1.0 : 0.0;\n"
"        }\n"
"        vec4 blendPix = mix(F, B, step(ColorDist(E, B), ColorDist(E, F)));\n"
"        res = mix(res, blendPix, GetLeftRatio(pos, origin, direction));\n"
"    }\n"
"    // Pixel Tap Mapping: -|x|x|-|-\n"
"    //                    x|A|B|C|-\n"
"    //                    x|D|E|F|-\n"
"    //                    -|G|H|-|-\n"
"    //                    -|-|-|-|-\n"
"    if (blendResult.x != BLEND_NONE) {\n"
"        float dist_D_C = ColorDist(D, C);\n"
"        float dist_B_G = ColorDist(B, G);\n"
"        bool doLineBlend = (blendResult.x == BLEND_DOMINANT ||\n"
"                            !((blendResult.w != BLEND_NONE && !IsPixEqual(E, C)) ||\n"
"                              (blendResult.y != BLEND_NONE && !IsPixEqual(E, G)) ||\n"
"                              (IsPixEqual(C, B) && IsPixEqual(B, A) && IsPixEqual(A, D) &&\n"
"                               IsPixEqual(D, G) && !IsPixEqual(E, A))));\n"
"        vec2 origin = vec2(0.0, -1.0 / sqrt(2.0));\n"
"        vec2 direction = vec2(-1.0, 1.0);\n"
"        if (doLineBlend) {\n"
"            bool haveShallowLine =\n"
"                (STEEP_DIRECTION_THRESHOLD * dist_D_C <= dist_B_G) && E != C && F != C;\n"
"            bool haveSteepLine =\n"
"                (STEEP_DIRECTION_THRESHOLD * dist_B_G <= dist_D_C) && E != G && H != G;\n"
"            origin = haveShallowLine ? vec2(0.0, -0.25) : vec2(0.0, -0.5);\n"
"            direction.x -= haveShallowLine ? 1.0 : 0.0;\n"
"            direction.y += haveSteepLine ? 1.0 : 0.0;\n"
"        }\n"
"        vec4 blendPix = mix(D, B, step(ColorDist(E, B), ColorDist(E, D)));\n"
"        res = mix(res, blendPix, GetLeftRatio(pos, origin, direction));\n"
"    }\n"
"    frag_color = res;\n"
"}\n"
"\n"

};

} // namespace HostShaders
