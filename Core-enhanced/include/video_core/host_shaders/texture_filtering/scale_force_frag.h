// Copyright 2022 Citra Emulator Project
// Licensed under GPLv2 or any later version
// Refer to the license.txt file included.

#pragma once

#include <string_view>

namespace HostShaders {

constexpr std::string_view SCALE_FORCE_FRAG = {
"// from https://github.com/BreadFish64/ScaleFish/tree/master/scale_force\n"
"\n"
"// MIT License\n"
"//\n"
"// Copyright (c) 2020 BreadFish64\n"
"//\n"
"// Permission is hereby granted, free of charge, to any person obtaining a copy\n"
"// of this software and associated documentation files (the 'Software'), to deal\n"
"// in the Software without restriction, including without limitation the rights\n"
"// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n"
"// copies of the Software, and to permit persons to whom the Software is\n"
"// furnished to do so, subject to the following conditions:\n"
"//\n"
"// The above copyright notice and this permission notice shall be included in all\n"
"// copies or substantial portions of the Software.\n"
"//\n"
"// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
"// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
"// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n"
"// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
"// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n"
"// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n"
"// SOFTWARE.\n"
"\n"
"//? #version 320 es\n"
"\n"
"precision mediump float;\n"
"\n"
"layout(location = 0) in vec2 tex_coord;\n"
"layout(location = 0) out vec4 frag_color;\n"
"\n"
"layout(binding = 0) uniform sampler2D input_texture;\n"
"\n"
"vec2 tex_size;\n"
"vec2 inv_tex_size;\n"
"\n"
"vec4 cubic(float v) {\n"
"    vec3 n = vec3(1.0, 2.0, 3.0) - v;\n"
"    vec3 s = n * n * n;\n"
"    float x = s.x;\n"
"    float y = s.y - 4.0 * s.x;\n"
"    float z = s.z - 4.0 * s.y + 6.0 * s.x;\n"
"    float w = 6.0 - x - y - z;\n"
"    return vec4(x, y, z, w) / 6.0;\n"
"}\n"
"\n"
"// Bicubic interpolation\n"
"vec4 textureBicubic(vec2 tex_coords) {\n"
"    tex_coords = tex_coords * tex_size - 0.5;\n"
"\n"
"    vec2 fxy = modf(tex_coords, tex_coords);\n"
"\n"
"    vec4 xcubic = cubic(fxy.x);\n"
"    vec4 ycubic = cubic(fxy.y);\n"
"\n"
"    vec4 c = tex_coords.xxyy + vec2(-0.5, +1.5).xyxy;\n"
"\n"
"    vec4 s = vec4(xcubic.xz + xcubic.yw, ycubic.xz + ycubic.yw);\n"
"    vec4 offset = c + vec4(xcubic.yw, ycubic.yw) / s;\n"
"\n"
"    offset *= inv_tex_size.xxyy;\n"
"\n"
"    vec4 sample0 = textureLod(input_texture, offset.xz, 0.0);\n"
"    vec4 sample1 = textureLod(input_texture, offset.yz, 0.0);\n"
"    vec4 sample2 = textureLod(input_texture, offset.xw, 0.0);\n"
"    vec4 sample3 = textureLod(input_texture, offset.yw, 0.0);\n"
"\n"
"    float sx = s.x / (s.x + s.y);\n"
"    float sy = s.z / (s.z + s.w);\n"
"\n"
"    return mix(mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n"
"}\n"
"\n"
"mat4x3 center_matrix;\n"
"vec4 center_alpha;\n"
"\n"
"// Finds the distance between four colors and cc in YCbCr space\n"
"vec4 ColorDist(vec4 A, vec4 B, vec4 C, vec4 D) {\n"
"    // https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.2020_conversion\n"
"    const vec3 K = vec3(0.2627, 0.6780, 0.0593);\n"
"    const float LUMINANCE_WEIGHT = .6;\n"
"    const mat3 YCBCR_MATRIX =\n"
"        mat3(K * LUMINANCE_WEIGHT, -.5 * K.r / (1.0 - K.b), -.5 * K.g / (1.0 - K.b), .5, .5,\n"
"             -.5 * K.g / (1.0 - K.r), -.5 * K.b / (1.0 - K.r));\n"
"\n"
"    mat4x3 colors = mat4x3(A.rgb, B.rgb, C.rgb, D.rgb) - center_matrix;\n"
"    mat4x3 YCbCr = YCBCR_MATRIX * colors;\n"
"    vec4 color_dist = vec3(1.0) * YCbCr;\n"
"    color_dist *= color_dist;\n"
"    vec4 alpha = vec4(A.a, B.a, C.a, D.a);\n"
"\n"
"    return sqrt((color_dist + abs(center_alpha - alpha)) * alpha * center_alpha);\n"
"}\n"
"\n"
"void main() {\n"
"    vec4 bl = textureLodOffset(input_texture, tex_coord, 0.0, ivec2(-1, -1));\n"
"    vec4 bc = textureLodOffset(input_texture, tex_coord, 0.0, ivec2(0, -1));\n"
"    vec4 br = textureLodOffset(input_texture, tex_coord, 0.0, ivec2(1, -1));\n"
"    vec4 cl = textureLodOffset(input_texture, tex_coord, 0.0, ivec2(-1, 0));\n"
"    vec4 cc = textureLod(input_texture, tex_coord, 0.0);\n"
"    vec4 cr = textureLodOffset(input_texture, tex_coord, 0.0, ivec2(1, 0));\n"
"    vec4 tl = textureLodOffset(input_texture, tex_coord, 0.0, ivec2(-1, 1));\n"
"    vec4 tc = textureLodOffset(input_texture, tex_coord, 0.0, ivec2(0, 1));\n"
"    vec4 tr = textureLodOffset(input_texture, tex_coord, 0.0, ivec2(1, 1));\n"
"\n"
"\n"
"    tex_size = vec2(textureSize(input_texture, 0));\n"
"    inv_tex_size = 1.0 / tex_size;\n"
"    center_matrix = mat4x3(cc.rgb, cc.rgb, cc.rgb, cc.rgb);\n"
"    center_alpha = cc.aaaa;\n"
"\n"
"    vec4 offset_tl = ColorDist(tl, tc, tr, cr);\n"
"    vec4 offset_br = ColorDist(br, bc, bl, cl);\n"
"\n"
"    // Calculate how different cc is from the texels around it\n"
"    float total_dist = dot(offset_tl + offset_br, vec4(1.0));\n"
"\n"
"    // Add together all the distances with direction taken into account\n"
"    vec4 tmp = offset_tl - offset_br;\n"
"    vec2 total_offset = tmp.wy + tmp.zz + vec2(-tmp.x, tmp.x);\n"
"\n"
"    if (total_dist == 0.0) {\n"
"        // Doing bicubic filtering just past the edges where the offset is 0 causes black floaters\n"
"        // and it doesn't really matter which filter is used when the colors aren't changing.\n"
"        frag_color = cc;\n"
"    } else {\n"
"        // When the image has thin points, they tend to split apart.\n"
"        // This is because the texels all around are different\n"
"        // and total_offset reaches into clear areas.\n"
"        // This works pretty well to keep the offset in bounds for these cases.\n"
"        float clamp_val = length(total_offset) / total_dist;\n"
"        vec2 final_offset = clamp(total_offset, -clamp_val, clamp_val) * inv_tex_size;\n"
"\n"
"        frag_color = textureBicubic(tex_coord - final_offset);\n"
"    }\n"
"}\n"
"\n"

};

} // namespace HostShaders
